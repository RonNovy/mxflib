/*! \file	mdobject.cpp
 *	\brief	Implementation of classes that define metadata objects
 *
 *			Class MDObject holds info about a specific metadata object
 *<br><br>
 *			Class MDOType holds the definition of MDObjects derived from
 *			the XML dictionary.
 *<br><br>
 *	\note
 *			These classes are currently wrappers around KLVLib structures
 */
/*
 *	Copyright (c) 2002, Matt Beard
 *
 *	This software is provided 'as-is', without any express or implied warranty.
 *	In no event will the authors be held liable for any damages arising from
 *	the use of this software.
 *
 *	Permission is granted to anyone to use this software for any purpose,
 *	including commercial applications, and to alter it and redistribute it
 *	freely, subject to the following restrictions:
 *
 *	  1. The origin of this software must not be misrepresented; you must
 *	     not claim that you wrote the original software. If you use this
 *	     software in a product, an acknowledgment in the product
 *	     documentation would be appreciated but is not required.
 *	
 *	  2. Altered source versions must be plainly marked as such, and must
 *	     not be misrepresented as being the original software.
 *	
 *	  3. This notice may not be removed or altered from any source
 *	     distribution.
 */

#include "mxflib.h"

using namespace mxflib;


//! MDDict constructor
/*! Loads the dictionary from the specified file
*/
void MDOType::DictManager::Load(const char *DictFile)
{
	// Load the KLVLib dictionary
	MainDict = LoadXMLDictionary(DictFile);

	if(MainDict == NULL)
	{
		error("Couldn't open dictionary file \"%s\"\n", DictFile);
		return;
	}

	// DRAGONS: Debug code in here to dump the top level
	DictEntry *Dict = MainDict;
	while(Dict != NULL)
	{
		DictEntry *p = Dict->Parent;
		while(p)
		{
			debug("*");
			p = p->Parent;
		};

		debug("DictEntry: %s\n", Dict->Name);

		// Add any top level types (and their children)
		if(Dict->Parent == NULL)
		{
			MDOType::AddDict(Dict);
		}

		// Continue looping
		Dict = Dict->Next;
	}


	// DRAGONS: Clumbsy code to sort out base types
	{
		MDOTypeList::iterator it = AllTypes.begin();

		while(it != AllTypes.end())
		{
			DictEntry *Base = (*it)->GetDict()->Base;

			if(Base != NULL)
			{
				if( DictLookup.find(Base) == DictLookup.end() )
				{
					error("Missing base type for MDOType \"%s\"\n", (*it)->GetDict()->Name);
				}
				else
				{
					(*it)->Base = DictLookup[Base];
				}
			}
			it++;
		}
	}
	
	// DRAGONS: More debug!
	MDOTypeList::iterator it = TopTypes.begin();
	while(it != TopTypes.end())
	{
		debug("MDOType: %s\n", (*it)->GetDict()->Name);

		MDOTypeList::iterator it2 = (*it)->Children.begin();
		while(it2 != (*it)->Children.end())
		{
			debug("  Sub->: %s\n", (*it2)->GetDict()->Name);

			MDOTypeList::iterator it3 = (*it2)->Children.begin();
			while(it3 != (*it2)->Children.end())
			{
				debug("    SubSub->: %s\n", (*it3)->GetDict()->Name);
				it3++;
			}

			it2++;
		}

		it++;
	}
}


//! Add a KLVLib DictEntry definition to the managed types
void MDOType::AddDict(DictEntry *Dict, MDOType *Parent /* = NULL */ )
{
	// Create a new MDOType to manage
	MDOTypePtr NewType = new MDOType(Dict);

	// Add to the list of all types
	AllTypes.push_back(NewType);

	// If it is a top level type then add it to TopTypes as well
	if(Dict->Parent == NULL) TopTypes.push_back(NewType);

	// If it is a child of another type then add to the children list
	if(Parent != NULL) Parent->Children.push_back(NewType);

	// Add any children of our own
	DictEntryList *ChildList = Dict->Children;
	while(ChildList != NULL)
	{
		// Rinse and repeat!
		AddDict(ChildList->Link, NewType);

		// Iterate through the list
		ChildList = ChildList->Next;
	}

	// Set the lookups
	DictLookup[Dict] = NewType;
	NameLookup[std::string(Dict->Name)] = NewType;
}


//! MDOType destructor
/*! Frees all items loaded and generated by this object
*/
MDOType::DictManager::~DictManager()
{
	// Free the main dictionary (as long as it has been loaded)
	if (MainDict) FreeDictionary(MainDict);
}



//! Builds an MDOType
/*! This constructor is private so the ONLY way to create
 *	new MDOTypes from outside this class is via AddDict()
*/
MDOType::MDOType(DictEntry *RootDict) : Dict(RootDict) 
{
	// Can't build an MDOType based on nothing
	ASSERT( RootDict != NULL );

	//! Determine the container type
	if( (RootDict->Type == DICT_TYPE_UNIVERSAL_SET) 
	  ||(RootDict->Type == DICT_TYPE_LOCAL_SET) )
	{
		ContainerType = SET;
	}
	else if( (RootDict->Type == DICT_TYPE_UNIVERSAL_SET) 
		   ||(RootDict->Type == DICT_TYPE_LOCAL_SET) )
	{
		ContainerType = PACK;
	}
	else if(RootDict->Type == DICT_TYPE_VECTOR)
	{
		ContainerType = VECTOR;
	}
	else if(RootDict->Type == DICT_TYPE_ARRAY)
	{
		ContainerType = ARRAY;
	}
	else
	{
		ContainerType = NONE;
	}
};


//! Find the MDOType object that defines a named type
/*! /ret Pointer to the object
 *  /ret NULL if there is no type of that name
 */
MDOType *MDOType::Find(const char *BaseType)
{
	MDOTypePtr theType;

	std::map<std::string,MDOTypePtr>::iterator it = NameLookup.find(std::string(BaseType));
	if(it == NameLookup.end())
	{
		return NULL;
	}

	theType = (*it).second;

	return (MDOType*)theType;
}


//! MDObject named constructor
/*! Builds a "blank" metadata object of a named type
*/
MDObject::MDObject(const char *BaseType)
{
	Type = MDOType::Find(BaseType);
	if(Type == NULL)
	{
		error("Metadata object type \"%s\" doesn't exist\n", BaseType);
		// DRAGONS: Must sort this!!
	}

	// Initialise the new object
	Init();
}


//! MDObject typed constructor
/*! Builds a "blank" metadata object of a specified type
*/
MDObject::MDObject(MDOType *BaseType) : Type(BaseType) 
{
	// Initialise the new object
	Init();
};


//! Second part of MDObject constructors
/*! Builds a "blank" metadata object
*/
void MDObject::Init(void)
{
	Size = 0;
	Data = NULL; 

	// If it isn't a container build the basic item
	if(Type->GetContainerType() == NONE)
	{
		// Build the minimum size item
		Size = Type->GetDict()->minLength;
		if(Size)
		{
			Data = new Uint8[Size];
			memset(Data, 0, Size);
		}
	}

	// If it's a fixed size array build all items
	else if(Type->GetContainerType() == ARRAY)
	{
// DRAGONS: Arg! Problems!!!
//		if(Type->Size > 0)
//		{
//			// Add a blank last item - forces all to be created
//			AddChild(new MDObject(Type), Type->Size - 1);
//		}
	}

};


//! Add a child to an MDObject continer
/*! If the container is an array the index number of the new object can be
 *! specified. If the index number is specified and a child already exists
 *! with that number it is replaced. If the index number is specified and
 *! it is not the next index available, extra 'empty' objects are added to
 *! grow the array to the appropriate size.
 */
void MDObject::AddChild(MDObject *Child, int Index /* = -1 */)
{
	ASSERT( Type->GetContainerType() != NONE );
	
	// Specific array index given
	if(Index >= 0)
	{
		// Can only specify an index for arrays
		ASSERT( Type->GetContainerType() == ARRAY );

		int Num = Children.size();

		// Replacing a current entry
		if(Num > Index)
		{
			MDObjectList::iterator it = Children.begin();

			// Move to the index point
			while(Index--) it++;

			// Insert the new item at this point
			Children.insert(it, Child);

			// Remove the old entry, automatically deleting the object if required
			Children.erase(it);

			// All done for replace operation
			return;
		}
		else
		{
			// Entry padding items required
			if(Index > Num)
			{
				MDObjectList::iterator it = Children.begin();

				while(Index > Num)
				{
					// Insert a new item of the same type at the end
					Children.push_back(new MDObject((*it)->Type));

					it++;
					Num++;
				}
			}
		}
	}

	// Add to the list of children
	Children.push_back(Child);
};


//! Remove children from an MDObject continer
/*! Remove all but the first "Index" children. 
 *! Probably only useful for resizing arrays.
 */
void MDObject::TrimChildren(int Index)
{
	ASSERT( Type->GetContainerType() != NONE );
	
	MDObjectList::iterator it = Children.begin();

	// Move to the index point
	while(Index--) it++;

	// Remove the old entries, automatically deleting the objects if required
	Children.erase(it, Children.end());
}


//! MDObject destructor
/*! Frees the data of the object if it exists
*/
MDObject::~MDObject()
{
	// Free any memory used
	if (Size) delete[] Data;
}


//!	Set the value of a metadata object from a "variable sized" chunk
/*! "variable sized" simply means that it has a size and a pointer
 *	as opposed to the fixed size integer data types
 *
 *	DRAGONS: If a data item is "shrunk" then grows again it may be
 *           re-allocated when this is not required...
 */
void MDObject::SetData(int ValSize, Uint8 *Val)
{
	// Can only set the value of an individual item
	ASSERT(Type->GetContainerType() == NONE);

	// Ignore containers in release mode
	if(Type->GetContainerType() != NONE) return;

	// Make sure we don't make the item bigger than allowed
	int MaxSize = Type->GetDict()->maxLength;
	
	// Enforce the size limit
	if(ValSize > MaxSize) ValSize = MaxSize;

	// Reallocate the data if it won't fit
	if(Size < ValSize)
	{
		if(Size) delete[] Data;
		Data = new Uint8[ValSize];
	}

	// Set the new data
	Size = ValSize;
	memcpy(Data, Val, ValSize);
}


//! Access array member within an MDObject array
/*! ?More detail?
*/
MDObjectPtr MDObject::operator[](int Index)
{
	MDObjectList::iterator it = Children.begin();

	while(Index--)
	{
		// End of list!
		if(it == Children.end()) return NULL;
	}

	// Return a smart pointer to the object
	return *(it);
}


//** Static Instantiations for MDOType class **
//*********************************************

MDOTypeList MDOType::AllTypes;	//!< All types managed by the MDOType class
MDOTypeList MDOType::TopTypes;	//!< The top-level types managed by the MDOType class

//! Map for reverse lookups based on DictEntry pointer
std::map<DictEntry*, MDOTypePtr> MDOType::DictLookup;

//! Map for reverse lookups based on type name
std::map<std::string, MDOTypePtr> MDOType::NameLookup;

MDOType::DictManager MDOType::DictMan;		//!< Dictionary manager

