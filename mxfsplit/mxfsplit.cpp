/*! \file	mxfsplit.cpp
 *	\brief	Splitter (linear sequential unwrap program) for MXFLib
 *
 *	\version $Id$
 *
 */
/* 
 *  This software is provided 'as-is', without any express or implied warranty.
 *  In no event will the authors be held liable for any damages arising from
 *  the use of this software.
 *  
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *  
 *   1. The origin of this software must not be misrepresented; you must
 *      not claim that you wrote the original software. If you use this
 *      software in a product, you must include an acknowledgment of the
 *      authorship in the product documentation.
 *  
 *   2. Altered source versions must be plainly marked as such, and must
 *      not be misrepresented as being the original software.
 *  
 *   3. This notice may not be removed or altered from any source
 *      distribution.
 */

#include "mxflib/mxflib.h"
using namespace mxflib;

#include "utility/osprintf.h"

// include the autogenerated dictionary
#include "mxflib/dict.h"

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <map>
#include <stdarg.h>
#include <math.h>
using namespace std;

#include "libmxfsplit/productIDs.h"

#include "libmxfsplit/testmxfsplit.h"

#include "libmxfsplit/libmxfsplit.h"

#include "libmxfsplit/containerinfo.h"

#include "libmxfsplit/IPartial.h"
#include "libmxfsplit/streamfile.h"
#include "libmxfsplit/basesink.h"

#include "libmxfsplit/audiosink.h"





#ifndef MAX_PATH
#ifdef PATH_MAX
#define MAX_PATH PATH_MAX
#else
#define MAX_PATH 255
#endif
#endif

#ifndef _WIN32
#define MAX_PATH 1024
#endif

#define SZ_OP_DIR (MAX_PATH+100)
static char OPdir[SZ_OP_DIR];



// DRAGONS: static file-scope is deprecated
// TODO: remove static and replace with empty namespace

//! Debug flag for KLVLib
int Verbose = 0;

//! Debug flag for MXFLib
bool DebugMode = false;		// -v

bool Quiet = false;			// -q

//! Enable Processor-based splitting with -p or -pX (X is kind of Sink - d,e,...)
char ProcSink = '\0';

static bool DumpAllHeader = false;	// -a
static bool SplitIndex = false;		// -i
static bool SplitGC = false;		// -g

static bool SplitWave = false;		// -w
static unsigned int SplitWaveChannels = 2;	// -w=n
static bool SplitMono = false;		// -m
static bool SplitStereo = false;	// -s

static bool SplitParts = false;		// -p
static bool FullIndex = false;		// -f dump full index
static bool DumpExtraneous = false;		// -x dump extraneous body elements


//values for partial restore
static unsigned int firstFrame=0;
static unsigned int nFrames=(unsigned int )-1;

// percentage
static bool OPPercentage=false;
Position  MXFFileLen; //used to estimate %age done
Uint64    DoneSoFar=0;

//! Should we pause before exit?
bool PauseBeforeExit = false;

//! DM Dictionaries
typedef list<std::string> DMFileList;
DMFileList DMDicts;


//! File Name Patterns

std::string  VideoFilePattern;
std::string  AudioFilePattern;
std::string  DataFilePattern;
std::string  SystemFilePattern;

std::string  DefaultFilePattern = "_%b04x_%t08x%xs";

int DefaultNumber = 0;					//!< The default file number, used for tokens #n and #N
int VideoNumber = 0;					//!< The video file number, used for tokens #v and #V
int AudioNumber = 0;					//!< The video file number, used for tokens #a and #A
int DataNumber = 0;						//!< The video file number, used for tokens #d and #D
int SystemNumber = 0;					//!< The video file number, used for tokens #s and #S
int GeneralNumber = 0;					//!< The video file number, used for tokens #g and #G



// forward references
PartitionPtr FindLatestClosedPartitionHeaderMetadata( MXFFile* File );
static void DumpObject(MDObjectPtr Object, std::string Prefix);
static void DumpHeader(PartitionPtr ThisPartition);
static void DumpIndex(PartitionPtr ThisPartition);

static void DumpBody(PartitionPtr ThisPartition, ContainerInfoPtr &EssenceLookup, StreamFileManager &StreamManager);

//! Build a filename from a pattern
std::string BuildFilename(std::string Pattern, UInt32 BodySID, UInt32 TrackNumber, std::string Extension);

//! Attempt to derive the extension for the given output stream, based on its descriptor
void DeriveExtension(StreamFile *Info, MDObjectPtr &Descriptor);


// Debug and error messages
#ifdef MXFLIB_DEBUG
//! Display a general debug message
void mxflib::debug(const char *Fmt, ...)
{
	if(!DebugMode) return;

	va_list args;

	va_start(args, Fmt);
	vprintf(Fmt, args);
	va_end(args);
}
#endif // MXFLIB_DEBUG

//! Display a warning message
void mxflib::warning(const char *Fmt, ...)
{
	va_list args;

	va_start(args, Fmt);
	printf("Warning: ");
	vprintf(Fmt, args);
	va_end(args);
}

//! Display an error message
void mxflib::error(const char *Fmt, ...)
{
	va_list args;

	va_start(args, Fmt);
	printf("ERROR: ");
	vprintf(Fmt, args);
	va_end(args);
}




// Declare main process function
int main_process(int argc, char *argv[]);

//! Do the main processing and pause if required
int main(int argc, char *argv[]) 
{
	char VersionText[256];
	snprintf(VersionText, 255, "MXFSplit %s.%s.%s(%s) of %s %s", 
		                       PRODUCT_VERSION_MAJOR,
							   PRODUCT_VERSION_MINOR,
							   PRODUCT_VERSION_TWEAK,
							   PRODUCT_VERSION_BUILD,
							   __DATE__, __TIME__);
	HandleVersionRequest(argc, argv, VersionText);

	int Ret=-1;
	Ret = main_process(argc, argv);

	if(PauseBeforeExit) PauseForInput();

	return Ret;
}



//! Do the main processing (less any pause before exit)
int main_process(int argc, char *argv[])
{
	//! The single Stream Manager object for managing our output files
	StreamFileManager StreamManager;

	int num_options = 0;
	OPdir[0]='\0';
	for(int i=1; i<argc; i++)
	{
		if(argv[i][0] == '-')
		{
			num_options++;
			char *p = &argv[i][1];					// The option less the '-' or '/'
			char Opt = tolower(*p);					// The option itself (in lower case)
			if(Opt == 'q') Quiet = true;
			else if(Opt == 'v') DebugMode = true;
			else if(Opt == 'd')
			{
				// DM Dictionary
				if(tolower(*(p+1))=='d')
				{
					char *name=""; // default name
					if( '='==*(p+2) || ':'==*(p+2))	name=p+3; // explicit name
					else if( i+1<argc ) name=argv[++i]; // explicit name in next arg

					if( strlen(name) ) 
					{
						DMDicts.push_back( std::string(name) );
					}
				}
				else
				{
					if( argv[i][2]==':' || argv[i][2]=='=' )
					{
						StreamManager.SetFileName( &argv[i][3] );
					}
					else
					{
						error("Missing file template for -d\n");
					}
				}
			}
			else if(Opt == 'f') FullIndex = true;
			else if(Opt == 'i')	SplitIndex = true;
			else if(Opt == 'g')	SplitGC = true;
			// else if(Opt == 'p') SplitParts = true;
			else if(Opt == 'a') DumpAllHeader = true;
			else if(Opt == 'm') SplitMono = true;
			else if(Opt == 'n')
			{
				const char *pPattern = NULL;

				// Determine pattern, either in this argument, or the following
				if((p[1] == '=') || (p[1] == ':')) pPattern = &p[2];
				else if( (p[1] != 0) && ((p[2] == '=') || (p[2] == ':'))) pPattern = &p[3];
				else if(argc > (i + 1)) pPattern = argv[++i];

				char c = tolower(p[1]);
				if((c == '?') || (pPattern == NULL))
				{
					fprintf(stderr, "\nFilename Patterns:\n\n");
					fprintf(stderr, "   (does NOT apply to framefile templates)\n");
					
					fprintf(stderr, "   -n=pattern  Set default filename pattern\n");
					fprintf(stderr, "  -na=pattern  Set filename pattern for audio files\n");
					fprintf(stderr, "  -nv=pattern  Set filename pattern for video files\n");
					fprintf(stderr, "  -nd=pattern  Set filename pattern for data essence files\n");
					fprintf(stderr, "  -ns=pattern  Set filename pattern for system data files\n\n");

					fprintf(stderr, "Patterns include tokens, each token is make up of '%%', a token character\n");
					fprintf(stderr, "and a printf-style format string.\n\n");
					
					fprintf(stderr, "Token characters:\n");
					fprintf(stderr, "   b = Body SID\n");
					fprintf(stderr, "   t = Track Number\n");
					fprintf(stderr, "   x = Derived file extension, including '.', or empty if not known\n");
					fprintf(stderr, "   # = Use a file number, specified in the following character\n\n");

					fprintf(stderr, "File Numbers:\n");
					fprintf(stderr, "   Each file number is a counter that starts at 0, and increments with each use.\n");
					fprintf(stderr, "   There are six counters intended for the following uses:\n\n");

					fprintf(stderr, "   v = Video file number\n");
					fprintf(stderr, "   a = Audio file number\n");
					fprintf(stderr, "   d = Data file number\n");
					fprintf(stderr, "   s = System file number\n");
					fprintf(stderr, "   n = 'Other' file number (when not one of the above)\n");
					fprintf(stderr, "   g = General file number, use when not numbering types separately\n\n");

					fprintf(stderr, "   Uppercase versions VADSN & G are the same value + 1 (so the first file is 1)\n\n");

					fprintf(stderr, "Token Examples:\n");
					fprintf(stderr, "   %%#b04x = The Body SID as a 4-digit hex number, zero padded\n");
					fprintf(stderr, "   %%#tu   = The Track Number as an unsigned integer, not padded\n");
					fprintf(stderr, "   %%#V02d = Video file number as 2-digit zero-padded integer (starts at 1)\n\n");

					fprintf(stderr, "Pattern Example:\n");
					fprintf(stderr, "   File-%%#Gd_Stream-%%bu__Track-%%t08x%%xs\n\n");
					
					fprintf(stderr, "Example Filenames (from above pattern):\n");
					fprintf(stderr, "   File-1_Stream-1__Track-15010500.mpg\n");
					fprintf(stderr, "   File-2_Stream-2__Track-16020301.wav\n");
					fprintf(stderr, "   File-3_Stream-2__Track-16020302.wav\n\n");

					return 1;
				}
				else if(c == 'v') VideoFilePattern = pPattern;
				else if(c == 'a') AudioFilePattern = pPattern;
				else if(c == 'd') DataFilePattern = pPattern;
				else if(c == 's') SystemFilePattern = pPattern;
				else DefaultFilePattern = pPattern;
			}
			else if(Opt == 's') SplitStereo = true;
			else if(Opt == '%') OPPercentage = true;
			else if(Opt == 'w') 
			{
				int sub = 2;
				if(true) // For future expansion...
				{
					SplitWave = true;
				}
				if( argv[i][sub]==':' || argv[i][sub]=='=' )
				{
					SplitWaveChannels = (unsigned int)strtoul( argv[i]+3, NULL, 0 );
				}
			}
			else if(Opt == 'o') 
			{
				strncpy( OPdir, argv[++i],  SZ_OP_DIR-1);
				if(!( OPdir[strlen(OPdir)-1]=='\\' || OPdir[strlen(OPdir)-1]=='/' ))
				{
					OPdir[strlen(OPdir)]='/';
					OPdir[strlen(OPdir)+1]='\0';
				}
				num_options++;
			}
			else if(Opt == 'p')
			{
				// Processor-based splitting
				ProcSink = 'd';						// default is to use Processor-based splitting with DataChunkSink
				if( p[1] == 'd' ) ProcSink = p[1];	// use Processor-based splitting with DataChunkSink
				if( p[1] == 'e' ) ProcSink = p[1];	// use Processor-based splitting with ExternalBufferSink
				// TODO if( p[1] == 'r' ) ProcSink = p[1];	// use Processor-based splitting with RawFileSink
			}
			else if(Opt == 'r')
			{
				firstFrame=atoi( argv[i+1] );
				nFrames=atoi( argv[i+2] );
				i+=2;
				num_options+=2;
			}
			else if(Opt == 'z') 
			{
				PauseBeforeExit = true;
			}
			else if(Opt == 'x') DumpExtraneous = true;
		}
	}

	if((argc-num_options) < 2)
	{
		fprintf( stderr,"\nUsage:  mxfsplit [options] <filename> \n" );
		fprintf( stderr,"                      [-pX] Enable Processor-based splitting and choose kind of Sink (d,e,r)\n");
		fprintf( stderr,"                       [-q] Quiet (default is Terse) \n" );
		fprintf( stderr,"                       [-v] Verbose (Debug) \n" );
		fprintf( stderr,"                       [-a] Dump all header metadata (and start of index)\n" );
		fprintf( stderr,"                       [-f] Dump Full Index \n" );
		fprintf( stderr,"              [-d=template] Divide each edit unit into its own file\n");
		fprintf( stderr,"                            (where template is the framefile name template)\n");
		fprintf( stderr,"                            (templates are file paths that must include one '%%d' field)\n");
		//fprintf( stderr,"                       [-i] Split Index Table Segments \n" );
		//fprintf( stderr,"                       [-g] Split Generic Containers into Elements \n" );
		fprintf( stderr,"                       [-w] Split AESBWF audio elements into wave files \n" );
		//fprintf( stderr,"                       [-m] Subdivide AESBWF Elements into mono wave files \n" );
		//fprintf( stderr,"                       [-s] Subdivide AESBWF Elements into stereo wave files \n" );
		//fprintf( stderr,"                       [-p] Split Partitions \n");
		fprintf( stderr,"               [-n=pattern] Set output filename pattern\n");
		fprintf( stderr,"                      [-n?] Detailed filename pattern help\n");
		fprintf( stderr,"                       [-x] Dump Extraneous Body Elements \n" );
		fprintf( stderr,"                       [-r <first frame> <nframes> ] Output a region of the MXF file\n");
		fprintf( stderr,"                       [-z] Pause for input before final exit\n");
		fprintf( stderr,"             [-dd=filename] Use DM dictionary \n" );

		return 1;
	}

	if(!Quiet) printf("MXFlib File Splitter\n" );

	// Load the dictionaries
	LoadDictionary( DictData );

	// load any DM Dictionaries
	DMFileList::iterator dd_it = DMDicts.begin();
	while( dd_it != DMDicts.end() )
	{
		MDOType::LoadDict( (*dd_it).c_str() );
		dd_it++;
	}

	//! Use New- or Old-style splitting
	int Ret = 0;
	if(ProcSink != '\0')
	{
		Ret = Simple( argv[num_options+1], firstFrame, nFrames, ProcSink );
	}
	else
	{
		MXFFilePtr TestFile = new MXFFile;
		if (! TestFile->Open(argv[num_options+1], true))
		{
			perror(argv[num_options+1]);
			return 1;
		}
		TestFile->SeekEnd();
		MXFFileLen=TestFile->Tell();
		TestFile->Seek(0);

		ContainerInfoPtr EssenceLookup = ContainerInfo::CreateAndBuild(TestFile);

		// If we don't already have one, get a RIP (however possible)
		if(TestFile->FileRIP.empty()) TestFile->GetRIP();

		// Iterate over Partitions
		RIP::iterator it = TestFile->FileRIP.begin();
		UInt32 iPart = 0;
		while(it != TestFile->FileRIP.end())
		{
			iPart++;

			if( !Quiet ) printf("\nPartition %4d at 0x%s for BodySID 0x%04x\n\n",
								iPart,
								Int64toHexString((*it).second->ByteOffset,8).c_str(),
								(*it).second->BodySID );

			TestFile->Seek((*it).second->ByteOffset);
			PartitionPtr ThisPartition = TestFile->ReadPartition();
			if(ThisPartition)
			{
				if(DumpAllHeader)
				{
					// Dump Partition Pack
					if( !Quiet )
					{
						printf( "Partition Pack:\n" );
						DumpObject(ThisPartition->Object,"");
						printf("\n");
					}

					// Header Metadata
					DumpHeader( ThisPartition );

					// Index Segments
					DumpIndex( ThisPartition );
				}
				
				// Body Elements
				DumpBody( ThisPartition, EssenceLookup, StreamManager );
			}
			it++;
		} // while(it != TestFile->FileRIP.end())

		TestFile->Close();
	}

	// Clear any streams that remain open
	StreamManager.Close();

	printf("DONE!\n");
	return Ret;
}



// find the most last Partition that is marked Closed
PartitionPtr FindLatestClosedPartitionHeaderMetadata( MXFFile* File )
{
	// Check the header partition
	File->Seek(0);
	PartitionPtr ThisPartition = File->ReadPartition();

	if(!ThisPartition)
	{
		error("Couldn't read the header partition\n");
		exit(1);
	}

	// Get a RIP (however possible)
	// already done prior to this call
	// File->GetRIP();

	// Check the footer first
	RIP::reverse_iterator rit = File->FileRIP.rbegin();
	
	// Scan backwards from the footer
	// Only the footer needs to be checked in a valid file, but this could be a partial file
	while(rit != File->FileRIP.rend())
	{
		ThisPartition = (*rit).second->ThePartition;

		File->Seek((*rit).second->ByteOffset);
		ThisPartition = File->ReadPartition();

		if(ThisPartition)
		{
			const std::string & nm=ThisPartition->Name();
			// First check that the partition is closed
			if(    (ThisPartition->Name().find("Footer") != std::string::npos)
				|| (ThisPartition->Name().find("Closed") != std::string::npos))
			{
				// Then that it has some metadata
				if(ThisPartition->GetUInt64("HeaderByteCount") != 0) break;
			}
		}
		else
			error("Null Partition \n");

		// Continue scanning backwards
		rit++;
	}

	if(rit == File->FileRIP.rend())
	{
		error("Cannot locate a closed set of metadata in file %s\n", File->Name.c_str());

		// By this time ThisPartition will contain the header - so we use that anyway!
	}

	if(!ThisPartition)
	{
		error("Failed to locate a usable partition\n");
		return NULL;;
	}
	else
	{
		return ThisPartition;
	}
}



// maximum value size to dump
// above this, dump will just state size
#define MAX_DUMPSIZE 128

//! Dump an object and any physical or logical children
void DumpObject(MDObjectPtr Object, std::string Prefix)
{
//	printf("0x%s in %s : ", Int64toHexString(Object->GetLocation(),8).c_str(), Object->GetSource().c_str());

	if(Object->IsModified()) printf("%s%s is *MODIFIED*\n", Object->FullName().c_str(), Prefix.c_str() );

	if(Object->GetLink())
	{
		if(Object->GetRefType() == DICT_REF_STRONG)
		{
			printf("%s%s = %s\n", Prefix.c_str(), Object->Name().c_str(), Object->GetString().c_str());
			printf("%s%s -> Strong Reference to %s\n", Prefix.c_str(), Object->Name().c_str(), Object->GetLink()->Name().c_str());
			DumpObject(Object->GetLink(), Prefix + "  ");
		}
		else
		{
			printf("%s%s -> Weak Reference to %s\n", Prefix.c_str(), Object->Name().c_str(), Object->GetLink()->Name().c_str());
		}
	}
	else
	{
		if(Object->IsDValue())
		{
			printf("%s%s = <Unknown>\n", Prefix.c_str(), Object->Name().c_str());
		}
		else
		{
//			const char* n=Object->Name().c_str();
			if( Object->IsAValue() )
			{
				if( Object->Value->GetData().Size > MAX_DUMPSIZE )
				{
					if(sizeof(size_t) == 4)
                        printf("%s%s = RAW[0x%08x]", Prefix.c_str(), Object->Name().c_str(), (int)Object->Value->GetData().Size );
					else
						printf("%s%s = RAW[0x%s]", Prefix.c_str(), Object->Name().c_str(), Int64toHexString(Object->Value->GetData().Size, 8).c_str() );

					const unsigned char* p = Object->Value->GetData().Data;
					int i; for(i=0;i<3;i++)
					{
						printf("\n%s%*c      ", Prefix.c_str(), (int)strlen(Object->Name().c_str()), ' ');
						int j; for(j=0;j<4;j++)
						{
							int k; for(k=0;k<4;k++) printf("%02x", *p++);
							printf(" ");
						}
						if(i==2) printf( "...\n" );
					}
				}
				else
					printf("%s%s = %s\n", Prefix.c_str(), Object->Name().c_str(), Object->GetString().c_str());
			}
			else
				printf("%s%s\n", Prefix.c_str(), Object->Name().c_str());
		}

		MDObjectULList::iterator it = Object->begin();
		while(it != Object->end())
		{
			DumpObject((*it).second, Prefix + "  ");
			it++;
		}
	}
	return;
}



void DumpHeader( PartitionPtr ThisPartition )
{
	if(ThisPartition->ReadMetadata() == 0)
	{
		if( !Quiet ) printf("No Header Metadata in this Partition\n\n");
	}
	else
	{
		if( !Quiet ) 
		{
			printf("\nHeader Metadata:\n");
			
			MDObjectList::iterator it2 = ThisPartition->TopLevelMetadata.begin();
			while(it2 != ThisPartition->TopLevelMetadata.end())
			{
				DumpObject(*it2,"  ");
				it2++;
			}
			printf("\n");
		}
	}
	return;
}



// FIXME not yet changed into xml-style output
void DumpIndex( PartitionPtr ThisPartition )
{
	// Read any index table segments!
	MDObjectListPtr Segments = ThisPartition->ReadIndex();
	if(Segments->empty())
	{
		if( !Quiet ) printf("No Index Table in this Partition\n\n");
	}
	else if( !DebugMode )
	{
		printf( "\nIndexTable:\n" );

		IndexTablePtr Table = new IndexTable;

		MDObjectList::iterator it = Segments->begin();

		while(it != Segments->end())
		{
			Table->AddSegment(*it);
		
			// Demonstrate this new segment
			
			UInt32 Streams = 1;
			MDObjectPtr DeltaEntryArray = (*it)[DeltaEntryArray_UL];
			if(DeltaEntryArray && DeltaEntryArray->GetType()->size())
			{
				Streams = static_cast<Uint32>(DeltaEntryArray->size() / DeltaEntryArray->GetType()->size());
				if(Streams == 0) Streams = 1;	// Fix for bad DeltaEntryArray
			}

			Position Start = (*it)->GetInt64(IndexStartPosition_UL);
			Length Duration = (*it)->GetInt64(IndexDuration_UL);
			
			UInt32 IndexSID = (*it)->GetUInt(IndexSID_UL);
			UInt32 BodySID = (*it)->GetUInt(BodySID_UL);
			
			if(Duration == 0) printf("CBR Index Table Segment (covering whole Essence Container) :\n");
			else printf("\nIndex Table Segment (first edit unit = %s, duration = %s) :\n", Int64toString(Start).c_str(), Int64toString(Duration).c_str());

			printf("  Indexing BodySID 0x%04x from IndexSID 0x%04x\n", BodySID, IndexSID);

			if(Duration < 1) Duration = 6;		// Could be CBR
			if(!FullIndex && Duration > 35) Duration = 35;	// Don't go mad!

			int i;
			printf( "\n Bytestream Order:\n" );
			for(i=0; i<Duration; i++)
			{
				UInt32 j;
				for(j=0; j<Streams; j++)
				{
					IndexPosPtr Pos = Table->Lookup(Start + i,j,false);
					printf("  EditUnit %3s for stream %d is at 0x%s", Int64toString(Start + i).c_str(), j, Int64toHexString(Pos->Location,8).c_str());
					printf(", Flags=%02x", Pos->Flags);
					if(Pos->Exact) printf("  *Exact*\n"); else printf("\n");
				}
			}

			printf( "\n Presentation Order:\n" );
			for(i=0; i<Duration; i++)
			{
				UInt32 j;
				for(j=0; j<Streams; j++)
				{
					IndexPosPtr Pos = Table->Lookup(Start + i,j);
					printf("  EditUnit %3s for stream %d is at 0x%s", Int64toString(Start + i).c_str(), j, Int64toHexString(Pos->Location,8).c_str());
					printf(", Flags=%02x", Pos->Flags);
					if( Pos->KeyFrameOffset ) printf(", Keyframe is at 0x%s", Int64toHexString(Pos->KeyLocation,8).c_str() );

					if(Pos->Exact) printf("  *Exact*\n");
					else if(Pos->OtherPos) printf(" (Location of un-reordered position %s)\n", Int64toString(Pos->ThisPos).c_str());
					else printf("\n");
				}
			}
			it++;
		}
	}
	return;
} // DumpIndex



void DumpBody(PartitionPtr ThisPartition, ContainerInfoPtr &EssenceLookup, StreamFileManager &StreamManager)
{

	UInt32 BodySID = ThisPartition->GetUInt( BodySID_UL );

	if( 0==BodySID )
	{
		if( !Quiet ) printf( "No Body in this Partition\n\n" );
	}
	else
	{
		if( !Quiet ) printf( "Elements for BodySID 0x%04x\n", BodySID );

		int limit=0;

		KLVObjectPtr anElement;
		ThisPartition->StartElements();
		while( anElement = ThisPartition->NextElement() )
		{
			EssenceSinkPtr ThisSink;
			// KLVFill is skipped already

			GCElementKind kind = anElement->GetGCElementKind();

			if( !kind.IsValid )
			{
				if(anElement->IsGCSystemItem())
				{
					if( !Quiet ) printf( "\nGC System: L=0x%s ", Int64toHexString( anElement->GetLength(), 8 ).c_str());

					// We are OK with system items
					kind.IsValid = true;
				}
				else if(anElement->IsGStreamItem())
				{
					if( !Quiet ) printf( "\nGeneric Stream: L=0x%s ", Int64toHexString( anElement->GetLength(), 8 ).c_str()); 

					// We are OK with generic stream items (we flag them as type 0)
					kind.IsValid = true;
					kind.ElementType = 0x00;
				}
				else
				{
					if(limit < 35)
					{
						if( !Quiet ) printf( "\nEXTRANEOUS (non-GC) Element: K=%s L=0x%s ", 
																	anElement->GetUL()->GetString().c_str(),
																	Int64toHexString( anElement->GetLength(), 8 ).c_str() );
						if( DumpExtraneous )
						{
							// anElement isa KLVObject

							// IDB the kludge with tmpUL is to get it to compile with GCC>3.4.0
							// see http://www.gnu.org/software/gcc/gcc-3.4/changes.html
							ULPtr tmpUL=anElement->GetUL();
							MDObjectPtr anObj = new MDObject( tmpUL );

							// this may take a long time if we only want to report the size of a mystery KLV
							anElement->ReadData();

							DataChunk& theChunk = anElement->GetData();
							anObj->ReadValue( theChunk );

							DumpObject( anObj, "  " );
							printf( "\n" );
						}
						if( ++limit >= 35 )
						{
							if(!Quiet) printf( "Excessive Extraneous Elements in this Partition...skipping reporting the rest\n" );
						}
					}
				}
			}
			else
			{
				if(!Quiet) printf( "\n" );
			}


			if(kind.IsValid)
			{
				/* Determine the essence type */

				UInt32 TrackNumber = 0;			//!< Track number of the essence in this stream
				PackagePtr Package;				//!< The package holding the current track
				MDObjectPtr Descriptor;			//!< Pointer to the file descriptor for this stream

				EssenceTrackDescriptorMap::iterator it = EssenceLookup->Lookup.find(BodySID);
				if(it == EssenceLookup->Lookup.end())
				{
					// DRAGONS: Suppress the warning for generic streams as they are not always linked in the same way (i.e. if not essence streams)
					if(kind.ElementType != 0) warning("BodySID %d not listed in header metadata\n", BodySID);

					// Add a dummy entry so we don't keep getting the same error
					EssenceTrackDescriptorPtr Dummy = new EssenceTrackDescriptor;
					EssenceLookup->Lookup[BodySID] = Dummy;
				}
				else
				{
					TrackNumber = anElement->GetGCTrackNumber();
					Descriptor = (*it).second->GetDescriptor(TrackNumber);
					Package = (*it).second->Package;
				}


				if( !Quiet )
				{
					printf( "GC Element: L=0x%s", Int64toHexString( anElement->GetLength(), 8 ).c_str());
				}

				bool StreamFound = false;
				StreamFile *Info = NULL;
				if(!StreamManager.DivideFiles)
				{
					Info = StreamManager.Find(BodySID, TrackNumber);
					if(Info)
					{
						ThisSink = Info->Sink;
						if((!Quiet) && (!Info->Name.empty())) printf(" File=%s", Info->Name.c_str() );
						StreamFound = true;
					}
				}

				if( !StreamFound )
				{

					// Add a new output stream
					
					std::string Pattern;
					if(((kind.Item & 0xef) == 0x04) && !SystemFilePattern.empty()) Pattern = SystemFilePattern;
					else if(((kind.Item & 0xef) == 0x05) && !VideoFilePattern.empty()) Pattern = VideoFilePattern;
					else if(((kind.Item & 0xef) == 0x06) && !AudioFilePattern.empty()) Pattern = AudioFilePattern;
					else if(((kind.Item & 0xef) == 0x07) && !DataFilePattern.empty()) Pattern = DataFilePattern;
					else if((kind.Item == 0x18) && !VideoFilePattern.empty()) Pattern = VideoFilePattern;
					else Pattern = DefaultFilePattern;

					if( (!Quiet) && (!StreamManager.DivideFiles) ) printf( " NEW" );

					// Make this stream (optionally adding it to the stream manager if we are not making one file per element)
					if(StreamManager.DivideFiles) Info = StreamManager.MakeStream(BodySID, TrackNumber, kind, Pattern);
					else Info = StreamManager.AddStream(BodySID, TrackNumber, kind, Pattern);
	
					if(!Descriptor)
					{
						// If we couldn't find a descriptor we can't get fancy with unwrapping the essence
						ThisSink = new RawFileSink(Info->OpenFile());
					}
					else
					{
						// Make a label that matches the essence container label for this essence (if there is one in the descriptor)
						// TODO: Should we try and figure this out if it is not in the descriptor?
						ULPtr ECLabel;
						MDObjectPtr ECLabelObject = Descriptor[EssenceContainer_UL];
						if(ECLabelObject)
						{
							DataChunkPtr Data = ECLabelObject->PutData();
							if(Data && (Data->Size == 16)) ECLabel = new UL(Data->Data);
						}

						// Are there any sub-descriptor?
						MDObjectList SubDescriptors;
						MDObjectPtr SubDesc = Descriptor->Child(SubDescriptors_UL);
						if(SubDesc)
						{
							MDObject::iterator it = SubDesc->begin();
							while(it != SubDesc->end())
							{
								if((*it).second && (*it).second->GetRef()) SubDescriptors.push_back((*it).second->GetRef());
								it++;
							}
						}

						if(SplitWave && (Descriptor->IsA(GenericSoundEssenceDescriptor_UL)))
						{
							UInt32 ChannelCount = Descriptor->GetUInt(ChannelCount_UL);
							UInt32 QuantizationBits = Descriptor->GetUInt(QuantizationBits_UL);
							
							// Assume 48k if we have problems!
							Int32 AudioSamplingRate = 48000;

							MDObjectPtr SamplingRate = Descriptor[AudioSamplingRate_UL];
							if(SamplingRate)
							{
								AudioSamplingRate = SamplingRate->GetInt("Numerator");
								Int32 Denom = SamplingRate->GetInt("Denominator");
								if(Denom != 0) AudioSamplingRate /= Denom;
							}

								ThisSink = new WaveFileSink(Info->OpenFile(".wav"), (int)ChannelCount, AudioSamplingRate, (int)QuantizationBits);

							if( !Quiet ) printf( " Wave" );
						}
						else
						{
							DeriveExtension(Info, Descriptor);
							ThisSink = new RawFileSink(Info->OpenFile());
						}
					}

					if((!StreamManager.DivideFiles) && (!Quiet)) printf(" File=%s", Info->Name.c_str() );
					/* Add partial filter if required */
					if(nFrames != -1)
					{
						ThisSink = new PartialSink(ThisSink, firstFrame, nFrames);
					}

					/* Add percentage filter if required */
					if(OPPercentage)
					{
						ThisSink = new ShowPercentSink(ThisSink, ThisPartition->GetParentFile() , MXFFileLen);
					}

					// Store the sink
					Info->Sink = ThisSink;
				}

				/* Copy the essence KLV to the output file in manageable chunks */
	
				// Limit chunk size to 32Mb
				const Length MaxSize = 32 * 1024 * 1024;

				Position Offset = 0;
				for(;;)
				{
					// Work out the chunk-size
					Length CurrentSize = anElement->GetLength() - (Length)Offset;
					if(CurrentSize <= 0) break;
					if(CurrentSize > MaxSize) CurrentSize = MaxSize;

					size_t Bytes = anElement->ReadDataFrom(Offset, static_cast<size_t>(CurrentSize));
					if(!Bytes) break;
					Offset += Bytes;

					//if(FileValid(ThisFile)) FileWrite(ThisFile, anElement->GetData().Data, anElement->GetData().Size);
					// FIXME: Need to add end-of-element
					if(ThisSink) ThisSink->PutEssenceData(anElement->GetData());
				}

				// If we are dividing into multiple files then we are done with this one
				if(StreamManager.DivideFiles)
				{
					//if( SplitWave && 0x16==(*itFile).second.kind.Item ) UpdateWaveLengths(ThisFile);
					if(ThisSink) ThisSink->EndOfData();
					StreamManager.Close();
				}
			}

			// Stop processing at the end of the partial clip (if we are doing partial)
			if((nFrames != -1) && (ThisSink)) 
			{
				IPartial *Partial = dynamic_cast<IPartial *>(ThisSink.GetPtr());
				if((Partial) && (Partial->EndOfPartial())) break;
			}
		}
	} // if( 0==BodySID )
	return;
}



//! Build a filename from a pattern
/*! Pattern Tokens:
 *
 *  Each token is make up of a %, a token character and a format string
 *
 *  Token characters:
 *    b = BodySID
 *    t = Track Number
 *    x = Derived file extension
 *    # = Use a file number, specified in the following character
 *
 *	File Numbers:
 *      Each file number is a counter that starts at zero, and increments with each use.
 *      There are six counters intended for the following uses:
 *
 *		v = Video file number
 *      a = Audio file number
 *      d = Data file number
 *      s = System file number
 *      n = 'Other' file number (when not one of the above)
 *      g = General file number, use when not numbering types separately
 *
 *      Uppercase versions V, A, D, S, N and G are the same value + 1 (so the first file is 1)
 *
 *  Token Examples:
 *    %b04x  = The BodySID as a 4-digit hex number, zero padded
 *    %t8u   = The track number as an eight-digit unsigned integer, space padded (not a good idea)
 *    %#V02u = One-based video file number as two-digit zero-padded unsigned integer
 */
std::string BuildFilename(std::string Pattern, UInt32 BodySID, UInt32 TrackNumber, std::string Extension)
{
	stringstream Ret;

	char Mode = '-';				// Initially we are not performing a substitution
	size_t StartPos = 0;			// Start from the start of the string
	size_t EndPos;
	do
	{
		// Find the first '%' in the string (or the end of the string)
		EndPos = Pattern.find('%', StartPos);
		if(EndPos == std::string::npos) EndPos = Pattern.length();

		switch(Mode)
		{
			default:
				// For all unknown tokens (and '-') just use what we found up to, but not including, the '%'
				Ret << Pattern.substr(StartPos, EndPos - StartPos);
				break;

			case 'b': case 'B':
				if((EndPos - StartPos) < 2) 
					Ret << "FormatError";
				else
					Ret << utility::osprintf(("%" + Pattern.substr(StartPos + 1, EndPos - (StartPos + 1))).c_str(), BodySID);

				break;

			case 't': case 'T':
				if((EndPos - StartPos) < 2)
					Ret << "FormatError";
				else
					Ret << utility::osprintf(("%" + Pattern.substr(StartPos + 1, EndPos - (StartPos + 1))).c_str(), TrackNumber);

				break;

			case 'x': case 'X':
				if((EndPos - StartPos) < 2)
					Ret << "FormatError";
				else
					Ret << utility::osprintf(("%" + Pattern.substr(StartPos + 1, EndPos - (StartPos + 1))).c_str(), Extension.c_str());

				break;
			
			// File number tokens
			case '#':
				if((EndPos - StartPos) < 3)
					Ret << "FormatError";
				else
				{
					// Select number by second character
					int Num;
					char NumberID = Pattern.at(StartPos + 1);
					switch(tolower(NumberID))
					{
						default:
						case 'n':	Num = DefaultNumber++; break;
						case 'v':	Num = VideoNumber++; break;
						case 'a':	Num = AudioNumber++; break;
						case 'd':	Num = DataNumber++; break;
						case 's':	Num = SystemNumber++; break;
						case 'g':	Num = GeneralNumber++; break;
					}

					// Make one-based if required
					if(tolower(NumberID) != NumberID) Num++;

					Ret << utility::osprintf(("%" + Pattern.substr(StartPos + 2, EndPos - (StartPos + 2))).c_str(), Num);
				}

				break;
		}

		StartPos = EndPos + 1;
		if(Pattern.length() > StartPos) Mode = Pattern.at(StartPos);
	} while(EndPos < Pattern.length());

	return Ret.str();
}



//! Attempt to derive the extension for the given output stream, based on its descriptor
/*! DRAGONS: Some extensions, such as .wav and .aiff, are handled separately */
void DeriveExtension(StreamFile *Info, MDObjectPtr &Descriptor)
{
	MDObjectPtr ECLabel = Descriptor->Child(EssenceContainer_UL);
	if(ECLabel)
	{
		DataChunkPtr ECData = ECLabel->PutData();
		if(ECData && (ECData->Size == 16))
		{
			if(Label::Matches("MXFGCMPEGES", ECData->Data)) Info->Extension = ".mpg";
			else if(Label::Matches("MXFGCDV", ECData->Data)) Info->Extension = ".dv";
		}
	}
}
